package VASSAL.tools;

import java.lang.reflect.InvocationTargetException;

public class ErrorUtils {
  private ErrorUtils() {}

  /**
   * Finds a {@link Throwable} of class <code>T</code> in the causal
   * history of the given <code>Throwable</code>, if one exists.
   *
   * @param cl the {@link Class} to search for
   * @param t  the <code>Throwable</code> to check
   * @return the ancestor of class <code>T</code>, or <code>null</code>
   * if none exists
   */
  public static <T extends Throwable> T getAncestorOfClass(Class<T> cl,
                                                           Throwable t) {
    // traverse the causal history of t until a cause of type cl is found
    for (Throwable c = t.getCause(); c != null; c = c.getCause()) {
      if (cl.isInstance(c)) return cl.cast(c);
    }

    return null;
  }
 
  /**
   * Throws a {@link Throwable} of class <code>T</code> if the
   * given <code>Throwable</code> has an ancestor of class <code>T</code>.
   *
   * @param cl the <code>Class</code> to search for
   * @param t the <code>Throwable</code> to check
   * @throws T if an ancestor of that class is found
   */
  public static <T extends Throwable> void throwAncestorOfClass(
      Class<T> cl, Throwable t) throws T {
    final T ancestor = getAncestorOfClass(cl, t);
    if (ancestor != null) {
      T toThrow = null;
      try {
        toThrow = cl.cast(cl.getConstructor().newInstance().initCause(t));
      }
      catch (Throwable ignore) {
        // If anything happens here, we're screwed anyway, since we're
        // already calling this during error handling. Just log it and
        // fight on.
        ErrorLog.log(ignore);
      }

      if (toThrow != null) throw toThrow;
    }
  }

  /**
   * Handle a {@link Throwable} generated by
   * <code>Class.getConstructor().newInstance()</code>.
   *
   * @param t the <code>Throwable</code>
   */ 
  public static void handleNewInstanceFailure(Throwable t) {
    // find and rethrow causes which are not bugs
    throwAncestorOfClass(OutOfMemoryError.class, t);

    handle(t, IllegalAccessException.class,
              IllegalArgumentException.class,
              InstantiationException.class,
              InvocationTargetException.class,
              NoSuchMethodException.class,
              SecurityException.class,
              ExceptionInInitializerError.class
    );
  }

  public static void handleMethodFailure(Throwable t) {
    // find and rethrow causes which are not bugs
    throwAncestorOfClass(OutOfMemoryError.class, t);

    handle(t, IllegalAccessException.class,
              IllegalArgumentException.class,
              InvocationTargetException.class,
              NoSuchMethodException.class,
              SecurityException.class,
              ExceptionInInitializerError.class
    );
  }

/*
  private static void rethrowAncestor(Throwable t, Class<?>... args) {
    for (Throwable c = t.getCause(); c != null; c = c.getCause()) {
      for (Class<?> cl : args) {
        if (cl.isInstance(c)) {
          
          try {
            toThrow = cl.cast(cl.getConstructor().newInstance().initCause(t));
      }
      catch (Throwable ignore) {
        // If anything happens here, we're screwed anyway, since we're
        // already calling this during error handling. Just log it and
        // fight on.
        ErrorLog.log(ignore);
      }

      if (toThrow != null) throw toThrow;
        }
      }
    }
  }
*/

  private static void handle(Throwable t, Class<?>... args) {
    // these errors are expected
    for (Class<?> cl : args) {
      if (cl.isInstance(t)) ErrorDialog.bug(t);
    }
  
    // otherwise something weird happened
    if (t instanceof Error) {
      // some unusual problem occurred    
      throw (Error) t;
    }
    else if (t instanceof RuntimeException) {
      // some unusual problem occurred    
      throw (RuntimeException) t;
    }
    else {
      // this should never happen
      throw new IllegalStateException(t);
    }
  }
}
